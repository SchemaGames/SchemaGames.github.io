<showdown>
One of the oldest and most well established game jams in existence today is the renowned Ludum Dare. I've done it several times (as of the time of writing, three times). Like most game jams, Ludum Dare offers the chance to test your mettle to see what you can produce when confronted with one of the most aggravating barriers to good game development most developers face - time. The classic form of the jam, termed the 'compo', only allows you 48 hours to make a game from scratch (though there is also a 'jam' form, it only gives you an additional 24 hours). In addition to the time restriction, there is a theme which is meant to be followed, which is not announced until the beginning of each game jam.

Constraints like these are not always a barrier to creativity, and can sometimes even help it along. If you come into a game jam with an open mind, there is a lot you can learn from having to constantly make production-style decisions along with your design-choices. Choices about what features to keep and what to cut, about when to sleep or eat and when to resume working, about how much to prepare before starting to develop your chosen concept, and about whether to keep using the tools you started with. Everyone has a process, and short-form games are a good introspection vehicle to see what that process really is. With that said, it's important to recognize what this guide offers; it's not for everyone.

### What This Guide Is Not
- A guide to making games that take more than a week to finish
- A guide to making your dream game
- A guide on ways to train your long-form game development skills

### What This Guide Is
- A guide on making quality short-form games

There's a lot to be said for and against game jams like these, but the important one for the purpose of this guide is that short-form games are a much different animal than a longer game. Since short-form games are something of a nebulous idea, I'll be focusing on what I know best: making a game in 48 hours during a jam. I'll assume your circumstances are the same, though you may still find this guide useful even if they're somewhat different. If this meets your expectations, you're in the right place. So without further ado, let's get started:

### Pre-Production
When you start on a long game project, you (and your team, if you have one) probably won't be starting an creating art assets and codebases immediately. Instead, you'll have to take some time to create some vision of what kind of game you're going to make. This is no less true when working on a short-form game, though the pre-productive phase will look a little bit different.

In truth, *your preproduction actually begins before your 48 hour clock starts ticking*. Most game jams have certain restrictions on doing work before the jam arrives; Ludum Dare's mechanism is to tell you in vague terms what the game will be about through the 'theme', making any previous work on a game worthless in many cases. Still, despite restrictions, most jams also encourage preparedness. Having a good tools pipeline, a clear schedule, and good health can make the difference between a great jam and a terrible one.

A mistake game developers sometimes make is reinventing the wheel, but luckily, many tools exist to make your job easier. Most of these (game engines being the archetypal example) are focusing on the code and programming aspects of game development, while others smoothen the process of making art, music, or game data. Some even exist solely to make your game easier to market or distribute. In most cases, *you'll be using more than one tool together*, in sequence. In the biz this is called a pipeline, and having one is not always enough. You should create your own pipeline out of tools you are proficient with, and that work well together. Not all tools are made with games in mind, but are still excellent choices to compose a pipeline.

You probably have a good idea of which tools are out there, and have almost certainly used a few if you're reading this guide. Some are free or open-source, while others are paid or proprietary. Some are monolithic, while others are just small command-line utilities, and many others still fill in everything in between. Some are digital, and some are analog. I leave the specifics of what your pipeline should be made of up to you, but I tend to use many tools that all do one thing to create individual assets, which I then import into a monolithic editor/IDE that can bring them together in the shape of a game. Pretty simple, but it works.

Next is making time for the jam. If you have distractions or obligations, they'll eat into the time you have to make a game. *Time is your most important resource - save it*. Make sure you plan far enough ahead to be able to minimize time wasted. Not much more to say about that now, though there's plenty to say about time use later.

Finally, make sure to come into the jam well rested and in good health. Losing sleep before or during the jam will eat into the attention and energy you have, which is just as bad as losing time during the jam. Getting enough sleep during the jam is equally important, even though it unequivocally eats into your time. There is some contention about this point, but I'll run a little math for you to help convince you sleeping during the jam is better.

Take the longest you've ever gone without sleeping, call that T (for me, this runs at almost 38 hours). If T's close enough to the 48 hours a whole jam lasts, you can assume that waking up when the jam starts and crashing will only allow you the time you're awake before crashing to work. Take the maximum amount of that time you actually felt productive, awake, or fresh (for me, probably only 22 of the 38 hours were "fresh") and call it F. Let's be generous and say you're half as productive (on average) while crashing. So add 50% of F to F (which gives me 33 hours), and divide it by the full jam time to get your efficiency (about 68.75% for me on a crash strategy).

Now let's say you wake up when the jam starts, and sleep a full night sometime in the middle. Take one good nights sleep as time t (I like sleep, so 10 hours for me), and subtract it from the 48 hours you have to make a game (acceptable losses make that 38/48). Now, since we're rested, our efficiency doesn't drop due to fatigue. I'll note that waking up and showering, eating, and stretching out a bit all take time away from your game too. However, one can assume one will do most of these activities in both scenarios; the only difference is waking up in the middle of the jam. Say this takes an hour. Then, the efficiency is 37 hours out of the 48, which is 77% (almost a ten percent difference). *Even while giving all sorts of slack to the crash strategy, the resting strategy still outperforms it*. This has been my own experience - I crashed in the middle of my first Ludum Dare game, and barely finished it after waking up a few hours before the deadline. I rested for each of my following games, and found I had time to spare on each.

You may wonder where conceptual planning, team-building, and prototyping fall into pre-production for a short-term game. The answer to this differs somewhat from long-term games, in that they actually happen during the jam time (with the possible exception of choosing your team beforehand, which I can't speak very well to, having done each of my jam games thus far solo). On that note, let's continue.

### Prototyping

The jam has started. The clock is ticking. Your precious seconds are being lost as you begin to formulate your game. So the next step is... prototyping? Yes! Many short-form games may simply be prototypes themselves, so you may wonder why one should bother prototyping after all the pre-production work. The answer is that *conceptual planning is your prototype*. And your concept should be more than just the theme or story, it should be a plan for how much work you want to attempt throughout the whole jam. How many mechanics, how they'll interact, how many art assets or lines of dialogue you'll need, how many levels, how many animation frames in a sprite. Ask yourself questions about the work and roughly guesstimate the answers to those questions. Make a plan, and make it well.

*Your plan will change*. This is almost inevitable, and should be; having to stick to your blueprint can be detrimental to the final product if you find that things don't work out how you thought they would. Learning the difference between the time each task will take and how long it actually takes you to do is one of the most important skills a game jam or short-form game has to teach, especially when working with new tools or workflows. Take no more than an hour to put a basic plan together; many people take far less. I usually have a good idea of what I'd like to do around a particular theme in 20 minutes, and know of others who do it in 5 (while still being able to state clearly what they're doing). Revise your plan whenever you need to during the remaining 35 work hours (accounting roughly for sleep and self-care), but only when you know how to make it better. And please do! Beating a dead horse won't get you so far when there's live one right next to you.

When it comes to picking a concept, your own creativity is the only factor. I can't help you here; nor can I help you with decisions on the content you make to fulfill that concept. This is the joy of game design, thankfully, so if you have a concept and plan that's of a reasonable size, and the ability to execute on it, these things will do the opposite of bother you - they'll be the reason to make a game to begin with! That said, short-form games are great ways to expand your skills, so feel free to *pick things slightly beyond your abilities*; challenging yourself will give far greater rewards than stagnating, so long as you don't bite off more than you can chew.

### Programming

This is the part which underpins most of the work you do on a game. The codebase is just like it sounds; it's a *foundation for all the work to follow*. Depending on your programming skills, luckily, you have a choice. You can let someone else do most of the work for you, at the benefit of time-savings, or you can do more of the work yourself, with the benefit of added flexibility.

You can usually use toolkits, engines, or other tools to provide many of the basic (often non-game specific) functions and libraries that come in handy during game creation. Modern game engines and game specific IDEs usually make the bulk of code-writing on your part support game logic, not the underlying machine interfacing. Using a premade codebase of someone else's make, whether open-source or licensed, can save you countless hours debugging and hair-pulling. *You will save hours using someone else's work at the cost of less control*.

On the other hand, you can write more of the code yourself. This will eat up your time, but can teach you very important game programming patterns. What you make might not look as shiny as a game made from a shiny engine, but you will know it inside and out. You can take pride in this kind of work, because it offers you absolute control over everything your medium is capable of. If you want to experiment with other kinds of games, at a very specific level, controlling the codebase might be the only way to do it. Losing time *might be worth it for the added power*, but this depends on your skill as a programmer.

*Your design goals should influence your choice here*. Do you want to make an ambitious game, full of features and mechanics that are fresh and interesting? Do you want to make detailed art and luxurious music? If your goals are high, like this, you'll need time to do it. To get this time, one way is to have a more robust codebase (that you know how to use). Go with a preexisting codebase. If you're looking to develop your coding style and skills, then feel free to start at a lower level, but unless you really know what you're doing, I would still suggest using some helper layer that provides interfaces to basic features (input, graphics, and sound). After all, you're not writing a game engine - you're coding up a game!

Speaking of which, when you're coding with a severe time constraint, here are some principles that might make things easier. Avoid abstractions - they aren't always necessary when you think they are. That said, don't repeat yourself. Build what you need, and nothing more. Use a language you know how to use. Deploy on a platform you know how to deploy to. Write code in a nice, fast text editor or IDE. Separate your concerns, whether through objects or modules or whatever. Decouple your code, so that when you change something, you only have to change it in one place. *Do whatever is right for the situation, before defaulting to a pattern*. And finally, if you don't write code, but you're working on a team with someone who is, let them know very clearly what you need, and make sure you know very clearly what they need from you.

### Graphics

Many tutorials on jam games are about the use or misuse of what is often termed "programmer art"; this is your basic placeholder art. While worth a mention, for short-form games, you should be more focused on a few other things: the level of detail of any graphics, the style of the graphics, and the dynamics of how they operate in the game. If you want to evoke certain feelings, graphics are among the simplest and most direct ways to do it.

Your game will have a resolution (or several). Even board games have graphics at a certain size and level of detail. When you read a book, or watch a film, or examine any visual medium, there is a way it is framed, a size at which all objects exist, and a relationship between each. Tinkering with the level of detail is *changing the sizing of your images*, whether internally (the "pixelation" of an image), or externally (the size of that image relative to the frame). Claustrophobia and agoraphobia are some feelings related to the level of detail - one could evoke either one through the relative size of the viewport (the game display) to items of interest (characters, enemies, set pieces). Maybe you like the retro aesthetic (in which case, make your images have a low internal level of detail to make them pixelated). Or perhaps you want to make things feel smooth (in which case, do the opposite and fill your images with smooth curves and fine detailing work). Having a low level of detail is less work (thus the high number of games that choose "retro graphics" or voxels), but it is still possible to have high detail art in a short-form game (vector art, though less common in games due to rendering concerns and varied formats, is a good way to achieve this).

Closely related is the style of your graphics. The color scheme you choose, the shapes and forms, the dimensionality, and the density of objects in your viewports are all means with which you can evoke different emotions and responses. You're providing stimuli to the player or players - *how do you want them to respond to the stimuli*? Traditionally, your art should reinforce the themes at play in your game mechanics, though some very good games have been made doing the opposite (contrast games are hard to pull off because they are so rare, but make me smile). See if your images reflect the soul of your game. They don't need to be complex or finely crafted to do this; just make them feel right.

Dynamics is possibly the most nebulous category, but is perhaps the most easily recognizable. Something moves - what does it look like when it moves? Does it animate? Is it fast? Slow? Are there many things swarming? Is it well lit? Maybe there's a filter on the screen making smoke trail by. What about a sword swinging? All these have to do with motion. Since this is a short-form game, there might or might not be many animated objects, but animations go a long way. Even if you have two frames that alternate, this is enough to give the illusion of speech. You can *use motion in your art in the same way that you can use any visual elements* - to demand a response from the player, or surprise them, or indicate that the world is not a static one.

When it comes down to it, I spend on the order of a third of my time in a game jam setting just making serviceable art. I don't make programmer art, though what I do make is nothing special. A proper digital artist would make something much better than I alone could. Still, making art twice (first programmer art, then a final draft of graphics to replace them) is a waste of time, and time is something you can't afford to waste. Instead, *make something simple to start, but modify it*, and add details, flourishes, until it looks good.

Don't be afraid to change things. Don't be afraid to undo things either. You can always go back and change it later. If you need art for testing purposes, *make the art as close to the final product as possible first*. When I was younger, I played the violin in school orchestra. One of my teachers once told me to always practice like I was delivering a concert, because when I was actually on a stage in front of parents and friends, I would play like I practiced. If I practiced playing casually with mistakes, I would play the same way later. Similarly, if you make programming art, and test your mechanics until they work, you might find that on changing the art for prime-time, your mechanics suddenly need tuning again. Change things as much as you need to, and nothing more.

But who says you have to have graphics at all? This is a short form game - you could be experimental and base your game entirely on sound, or tactile sensations. Don't be afraid to push some boundaries.

### Sound

Your music and sound effects perform much a similar role to your art - they provide an emotional effect in your game, and often a mechanical role as well. Making music and sound effects for your game also depends largely on the type of game you're making, what style you choose. The *exact nature of the music you make is up to you*, as with the art, but I'll be talking about methods for making quality sound.

You can make music in any of a number of ways, but whatever method you use, eventually the audio will have to transition to an audio format you game engine can use. It is worth your time to know the difference between lossy (.aac, .mp3, and .ogg are all examples) and lossless audio formats (.flac is one such). Notably, the Ogg Vorbis (lossy) and M4A (also lossy) audio formats are inclusive enough to cover compatibility with almost all web browsers, if that's where you're deploying your game. Otherwise, you have a bit more freedom with what audio formats to use, if any. Choose what is right for your game, or, when several formats are equally appealing, use the most popular one (which ensures greater support in the case that you need it). And *choose your formats ahead of time*! Perhaps do some test runs, ensure that you can make quality audio compatible with your game engine in the format of choice. The last thing you need is to create an amazing song, only to have it unusable because your engine doesn't know how to play it.

When making music, you have several choices. As with graphics, you can use software tools or analog methods (acoustic instruments if you know how to play, along with a microphone). Don't undersell the second method; I've used a $5 clip microphone meant for presentations and still produced decent audio with a piano. If you can improvise, or play by ear, you have a leg up. Simply record yourself playing around for perhaps thirty minutes to an hour, and then cut the bits you like out and make that your game's soundtrack. If you don't have the methods to make music acoustically, don't worry. There are plenty of proprietary or open source tools that you can use to create audio, even some that have been made specifically for game jams. If you haven't already done so, find one you like, and learn how to use it. Don't see the software method as superior or inferior to the acoustic method. Some shining examples have come out of both methods of music creation, or hybrids of the two.

But maybe you're not a musician, and have no idea how to make music. Or have no team members who fit the role. Not all is lost - not all games need music. Silence can be deafening, but there's plenty of audio that isn't inherently musical. Sound effects are simpler to make and implement - tie them to game events, introduce a little variation in them, and they can be enough. Bleeps and bloops, footsteps, door creaks, small explosions. All of them are markers that enhance immersion, and can do a better job of it than orchestral-style scores. *Don't underestimate the power of sound effects in producing atmosphere* - they're as subliminal as the scaling effects of your graphics are.

### Design

This is all you, sport! The traditional advice applies. Don't over-commit. Make something small and build on it. Have something testable as soon as possible. But whatever you make, make it good. *Make something you would want to play*.

### Deployment

Okay, so after tons of work, you have a game. You're still a few hours short of the time limit, but you need to put the game somewhere. Perhaps you need to have a URL where your game can be found, or need to submit it in a particular format to a portal. Maybe you just need to have a copy to throw on a flash drive. Whatever the case is, your game won't be very successful and *you won't learn all that you can learn if you don't put the work out there*. And unfortunately, putting it out there takes time, and more work.

Luckily, there are tons of resources. Do you have your own website? You can host the files there and put a download link somewhere on it, or even embed it if its a web game. Have a file syncing service like Dropbox? Those can produce sharing URLs easily and quickly. Need to compile everything into a particular format? This is one of the things you need to consider when picking an engine and framework, to ensure your players can use the fruit of your labors. Need to deploy to several operating systems, consoles, and/or the web? Same deal - look into cross-compilers or multi-platform frameworks to help you out. On top of this, there are many websites which offer hosting for you if you have a game (though they may often monetize your game for themselves using advertisements). There's still usually a free way to share your game, and this part can be very low-effort if you figure out what you'll do to deploy even before you start work on the game.

However, there's another side to this which deserves your attention: marketing. Making sure people know about your game and want to play it is hard and getting harder all the time, as more and more people join the development side of the games industry. If you want their feedback and word of mouth, you're going to have to work for it. Put some time into figuring out channels where you can plug your game, without breaking rules or ruffling feathers. If you're lucky, you might be making the game for a market which has promotion built-in. For example, Ludum Dare's voting system ensures that people who give more attention to other people's games get more attention for their own (a wonderful example of a benevolent cycle). If you're less lucky, you can always create promotional materials for your game itself (logos, splash screens, time-lapse videos of you making the game, elevator pitch snippets of text, etc). Often, a link is one of the most effective methods - someone will click it, and then they will be playing your game. Just like that!

### Conclusion

Who reads conclusions anyway? Go make a game, you reader you!

</showdown>